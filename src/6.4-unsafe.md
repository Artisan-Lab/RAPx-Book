# Chapter 6.4. Unsafe Code Audit
We provide three key features for auditing unsafe code:
* Audit unit generation: Segmenting a Rust crate into multiple code units to examain the correctness of code safety declaration and safety property labeling.
* Safety property inference: Inferring the safety property of unsafe APIs based on the audit unit.
* Safety property verification: Verifying if the safety property required by unsafe APIs are satisfied.

## Audit Unit Generation
The unsafety propogation graph(UPG) is a novel method to model the essential usage and encapsulation of unsafe code. UPG combines the traditional call graph with unsafe and dataflow information from Rust to capture the use and propagation of unsafe code across the project.

Within the UPG, there contains four major isolation types and nine structural patterns to split a UPG into several small self-contained subgraphs. These subgraphs called unsafety isolation graphs(UIGs) can serve as useful audit units for examining the soundness of unsafe code encapsulation.

We will continue to explore and investigate more effective applications of UIG in the encapsulation of unsafe code in our subsequent research.

Before using this feature, make sure that `graphviz` is installed on your device.

#### generate upg
Get into the same directory as cargo.toml and run the cmd below from the teminal. 
```
cargo rapx -upg
```
Then 'rapx' will create a directory named 'UPG' in the same level, which contains several connected unsafety propogation graphs.

#### count uig
This feature is numerically calculated based on the type of all uig in the target crate
```
cargo rapx -uig
```

#### check safety doc
With the following cmd, users can check for unsafe apis that lack an unsafe document annotation
```
cargo rapx -doc
```
RAPx will output the corresponding unsafe api information, including its location and visibility level as follows:
```
Lack of unsafety doc: src/lib.rs:1668:1: 1674:11 (#0), visibility:Restricted(DefId(0:0 ~ smallvec[ecd8])).
Lack of unsafety doc: src/lib.rs:1699:1: 1704:11 (#0), visibility:Restricted(DefId(0:0 ~ smallvec[ecd8])).
Lack of unsafety doc: src/lib.rs:960:5: 960:45 (#0), visibility:Restricted(DefId(0:0 ~ smallvec[ecd8])).
```

## Safety Property Inference
#### audit unsafe APIs' SP in `core` and `alloc`
Specifically, we currently integrate a set of SP labels analysis for `core` and `alloc` crate of the Rust standard library.
1. Create a new `helloworld` project.
2. Navigate to the `helloworld` project directory and run:
```
cargo rapx -stdsp -- -Z build-std --target x86_64-unknown-linux-gnu > /your/output/log/path/result.log 2>&1
```
Replace /your/output/log/path with your desired output directory. This will output APIs where the caller and callee have different SPs.


## Safety Property Verification
**Senryx** is the module within RAPx responsible for verifying safety properties. It operates as follows:

![Architecture of verification tool](figure/workflow.png)
### 1 Overview
The [tag-std](https://github.com/Artisan-Lab/tag-std/blob/main/primitive-sp.md) project has previously extracted safety properties for the vast majority of unsafe APIs in the Rust standard library. Building upon these annotations, **Senryx** employs a **tag-based verification approach** to determine whether the target code contains undefined behavior (UB).

**Senryx** operates under two **core assumptions**:
* **P1:** All undefined behavior originates from unsafe code blocks.
* **P2:** A function is sound if, along all possible execution paths, it satisfies the safety properties required by the unsafe code it interacts with.

### 2 Workflow:
#### 2.1 Contract Construction
**Senryx** utilizes the property annotations for the Rust std-lib provided by tag-std, constructing a framework of specifications recognizable by RAPx. For example:
```rust
#[rapx::inner(property = Align (data, T), kind = "precond")]
#[rapx::inner(property = NonNull (data, T), kind = "precond")]
#[rapx::inner(property = ValidPtr (data, T, len), kind = "precond")]
#[rapx::inner(property = Init (data, T, len), kind = "precond")]
#[rapx::inner(property = InBound (data, T, len), kind = "precond")]
#[rapx::inner(property = Alive (ret), kind = "hazard")]
#[rapx::inner(property = Alias (data), kind = "hazard")]
pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {
    ...
}
```
We need to fork the Rust standard library to apply the above-mentioned annotation format to all the unsafe APIs. Subsequently, use the following command to build the target crate that we wish to analyze:
```
cd /to-be-verified-crate/

export RUSTUP_TOOLCHAIN=nightly-2025-06-02
export __CARGO_TESTS_ONLY_SRC_ROOT=/path-to-pre-annotated-std-lib/library

// In Linux
cargo +nightly-2025-06-02 rapx -verify -- -Zbuild-std=panic_abort,core,std --target x86_64-unknown-linux-gnu
// In Mac(Arm)
cargo +nightly-2025-06-02 rapx -verify -- -Zbuild-std=panic_abort,core,std --target aarch64-apple-darwin
```
This command will load all the contracts that have been pre-annotated. If the target crate uses `slice::from_raw_parts`, then the static analyzer will check the contracts of it based on the program state.

#### 2.2 Program State
**Senryx** analyzes the current crate at the **MIR** level. For each variable in the MIR, it maintains the necessary program states as dictated by the contracts. All state information is recorded within a data structure termed the Dominated Graph (DG).

As shown below, DG employs two forms to record the state of variables: (i) All annotations preceding the unsafe code will construct the **Contractual Invariant States (CIS)** of the variables; (ii) The static analyzer analyzes step by step along the MIR path and infers the **Operational Trace States (OTS)** based on the semantics. 

When reaching the point where unsafe code is called, it will check whether the input parameters can pass through the contracts. For example, `ptr::offset` has the following contracts:
```rust
// InBounded (ptr, u32, count)
// ValidNum (count * size_of(T) <= isize::MAX)
pub const unsafe fn offset(self, count: isize) -> *mut T {
    ...
}
```
Checking process of **Senryx**:
(1) Since the original memory (**Var10**) has the `Allocated` and `Init` states, the generated alias pointer **Var5** also inherits this state accordingly and has the `ValidPtr` semantic.
(2)When reaching the call point of `ptr::offset`, since the `ValidPtr(ptr, u32, var11)` of **Var5** contains the OTS `InBound(ptr, u32, var11)`, and the CIS of **Var2** satisfies `Range(<=Var11)` and `Range(<=isize::MAX/4)`, these contracts have been passed.

![Architecture of verification tool](figure/DG.png)

#### 2.3 Hazard Path Analysis
Before reaching the unsafe call site, we need to track the variable states of its arguments. They may be affected by other variables along the path. We refer to such paths as **hazard paths**.

If the analysis target is a method taking `self` as an argument, its hazard paths comprise two components:
* Inter-procedural paths combining constructors and mutable methods. This can be referred to in the **_Adt analyzer_** section of the above architecture diagram. The algorithm for generating mutable method sequence is still under development.
* Intra-procedural paths from the function's entry point(s) to unsafe call sites within the method body.

If the analysis target is a function without a `self` parameter, only the latter is considered.

