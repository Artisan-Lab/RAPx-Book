# Chapter 6.4. Unsafe Code Audit and Verification
## 1 Overview
We provide three key features related to unsafe code:

(1) Audit unit generation: Segmenting a Rust crate into multiple code units to examain the correctness of code safety declaration and safety property labeling.

(2) Safety property verification: Verifying if the safety property required by unsafe APIs are satisfied.

(3) Safety property inference: Inferring the safety property of unsafe APIs based on the audit unit.

Among them, the **audit unit**, in combination with [tag-std](https://github.com/Artisan-Lab/tag-std/blob/main/primitive-sp.md), forms the basic analytical framework for **verification** and **inference**. The tag-std is a project which previously extracted safety properties for the vast majority of unsafe APIs in the Rust standard library. During the verification and inference processes, the **audit unit** determines the analysis boundaries, and the tags specify the fundamental elements for verification and inference.

All of our analyses are based on the following two **core assumptions**:
* **P1:** All undefined behavior originates from unsafe code blocks.
* **P2:** A function is sound if, along all possible execution paths, it satisfies the safety properties required by the unsafe code it interacts with.

## 2 Audit Unit Generation
The audit unit is a novel method to model the essential usage and encapsulation of unsafe code. It combines the traditional call graph with unsafe and dataflow information from Rust to capture the use and propagation of unsafe code across the project.

Here are two simple structures along with their corresponding constructors and methods. After we construct them through generation algorithm, we will obtain the `audit unit` of them. More detailed information can be obtained in [our paper](https://arxiv.org/abs/2504.21312).

```rust
struct St1 { ptr: *mut u8, len: usize }
struct St2 { pub ptr: *mut u8, pub len: usize }
impl St1 {
    pub fn from(p: *mut u8, l: usize) -> St1 {
        St1 { ptr: p, len: l }
    }
    pub fn set_len(&mut self, l:usize) {
        self.len = l;
    }
    pub unsafe fn get(&self) -> &[u8] {
        slice::from_raw_parts(self.ptr, self.len)
    }
}
impl St2 {
    pub unsafe fn from(p: *mut u8, l: usize) -> St2 {
        St2 { ptr: p, len: l }
    }
    pub unsafe fn set_len(&mut self, l:usize) {
        self.len = l;
    }
    pub fn get(&self, x: usize) -> u8 {
        if x < self.len {
            unsafe { *self.ptr.offset(x as isize) }
        } else {
            0
        }
    }
}
fn f1(v: Vec<u8>) {
    let (p,l,_c) = v.into_raw_parts();
    let s1 = St1::from(p, l); 
    f2(); 
}
fn f2() {
    let mut v = vec![1,2,3];
    let (p,l,_c) = v.into_raw_parts();
    let s2 = unsafe { St2::from(p, 0)};
    unsafe { s2.set_len(p, l)};
    let t2 = s2.get(0);
}
```


![graph1](figure/graph1.png)

**Fig-1a**: Unsafety propagation graph. The node f1 and function calls f1->f2, f1->St1::from, and f2->St2::get are not considered in the UPG.

![graph2](figure/graph2.png)
**Fig-1b**: Basic units generated by splitting Fig-1a.

![graph3](figure/graph3.png)
**Fig-1c**: Audit units generated by merging Fig-1b.

## 3 Safety Property Verification
**Senryx** is the module within RAPx responsible for verifying safety properties. Building upon the annotations from tag-std, **Senryx** employs a **tag-based verification approach** to determine whether the target code contains undefined behavior (UB).
It operates as follows:

![Architecture of verification tool](figure/workflow.png)


### 3.1 Contract Construction
**Senryx** utilizes the property annotations for the Rust std-lib provided by tag-std, constructing a framework of specifications recognizable by RAPx. For example:
```rust
#[rapx::inner(property = Align (data, T), kind = "precond")]
#[rapx::inner(property = NonNull (data, T), kind = "precond")]
#[rapx::inner(property = ValidPtr (data, T, len), kind = "precond")]
#[rapx::inner(property = Init (data, T, len), kind = "precond")]
#[rapx::inner(property = InBound (data, T, len), kind = "precond")]
#[rapx::inner(property = Alive (ret), kind = "hazard")]
#[rapx::inner(property = Alias (data), kind = "hazard")]
pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {
    ...
}
```
We need to fork the Rust standard library to apply the above-mentioned annotation format to all the unsafe APIs. Subsequently, use the following command to build the target crate that we wish to analyze:
```
cd /to-be-verified-crate/

export RUSTUP_TOOLCHAIN=nightly-2025-06-02
export __CARGO_TESTS_ONLY_SRC_ROOT=/path-to-pre-annotated-std-lib/library

// In Linux
cargo +nightly-2025-06-02 rapx -verify -- -Zbuild-std=panic_abort,core,std --target x86_64-unknown-linux-gnu
// In Mac(Arm)
cargo +nightly-2025-06-02 rapx -verify -- -Zbuild-std=panic_abort,core,std --target aarch64-apple-darwin
```
This command will load all the contracts that have been pre-annotated. If the target crate uses `slice::from_raw_parts`, then the static analyzer will check the contracts of it based on the program state.

### 3.2 Program State
**Senryx** analyzes the current crate at the **MIR** level. For each variable in the MIR, it maintains the necessary program states as dictated by the contracts. All state information is recorded within a data structure termed the Dominated Graph (DG).

As shown below, DG employs two forms to record the state of variables: 

(i) All annotations preceding the unsafe code will construct the **Contractual Invariant States (CIS)** of the variables; 

(ii) The static analyzer analyzes step by step along the MIR path and infers the **Operational Trace States (OTS)** based on the semantics. 

When reaching the point where unsafe code is called, it will check whether the input parameters can pass through the contracts.

#### Poc of Dominated Graph
For example, the function `xor_secret_region` is the target that we need to verify whether it can cause UB. Then we follow the tag-std format to label it.
```rust
/// Record secret buffer with its size.
struct SecretRegion {
	buffer: Vec<u32>,
    size: usize,
}

// ValidPtr (ptr, u32, 1)
// Aligned (ptr, u32)
// Init (ptr, u32, 1)
// ValidNum (offset >= 0)
// ValidNum (region.size >= offset)
// ValidNum (offset * 4 <= isize::MAX)
// Allocated (region.buffer, u32, region.size)
// Init (region.buffer, u32, region.size)
pub unsafe fn xor_secret_region(
    ptr: *mut u32,
    offset: isize,
    region: SecretRegion
) -> u32 {
    let mut src_value = ptr.read();
    let secret_ptr = region.buffer.as_ptr();
    let secret_region = secret_ptr.offset(offset);
    let secret_value = secret_region.read();
    src_value ^= secret_value;
    src_value
}

```

This function uses two std unsafe APIs:`ptr::read` and `ptr::offset`. What we need to do is to verify whether the contracts below have been fulfilled in the program:

```
Contracts of ptr::read
// ValidPtr (ptr, u32)
// Aligned (ptr, u32)
// Init (ptr, u32, 1)

Contracts of ptr::offset
// InBounded (ptr, u32, count)
// ValidNum (count * size_of(T) <= isize::MAX)

```

Subsequently, **Senryx** will perform state assignment for the variables based on abstract interpretation using the annotations and function MIR:

![MIR of Poc](figure/dg1.png)

**Dominated graph** for this MIR:

![DG of Poc](figure/dg2.png)

***Contract checking process of Senryx** (Illustrated by the case of `ptr::offset`):

(1) **InBounded (ptr, u32, count)**

* Since the original memory (**Var10**) has the `Allocated` and `Init` states, the generated alias pointer **Var5** also inherits this state accordingly and has the `ValidPtr` semantic.

* When reaching the call point of `ptr::offset`, since the `ValidPtr(ptr, u32, var11)` of **Var5** contains the OTS `InBound(ptr, u32, var11)`, and the CIS of **Var2** satisfies `Range(<=Var11)`, this contract has been passed.

(2) **ValidNum (count * size_of(T) <= isize::MAX)**

* **Var2** has the CIS `Range(<=isize::MAX/4)`, combined with the type of element is `u32`, so it can ensure the total length does not exceed `isize::MAX`.

### 3.3 Hazard Path Analysis
Before reaching the unsafe call site, we need to track the variable states of its arguments. They may be affected by other variables along the path. We refer to such paths as **hazard paths**.

If the analysis target is a method taking `self` as an argument, its hazard paths comprise two components:
* Inter-procedural paths combining constructors and mutable methods. This can be referred to in the **_Adt analyzer_** section of the above architecture diagram. The algorithm for generating mutable method sequence is still under development.
* Intra-procedural paths from the function's entry point(s) to unsafe call sites within the method body.

If the analysis target is a function without a `self` parameter, only the latter is considered.



## 4 Safety Property Inference
### 4.1 audit unsafe APIs' SP in `core` and `alloc`
Specifically, we currently integrate a set of SP labels analysis for `core` and `alloc` crate of the Rust standard library.
1. Create a new `helloworld` project.
2. Navigate to the `helloworld` project directory and run:
```
cargo rapx -stdsp -- -Z build-std --target x86_64-unknown-linux-gnu > /your/output/log/path/result.log 2>&1
```
Replace /your/output/log/path with your desired output directory. This will output APIs where the caller and callee have different SPs.

